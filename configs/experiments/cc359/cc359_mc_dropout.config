from ...assets.core import *
from ...assets.utils.no_pred import *
from ...assets.dataset.cc359 import *
from ...assets.batch_iter.patch_sampling_3d import *
from ...assets.architecture.unet3d import *
from ...assets.cross_val.cv_cc359 import *
from ...assets.metric.metrics_3d import *

from dpipe.torch.functional import weighted_cross_entropy_with_logits
from ood.torch.module.unet_mc_dropout import UNet3D_MC_Dropout
from ood.metric.ood_metric import evaluate_individual_metrics_probably_with_ids_no_pred_mc_dropout 
from ood.metric.ood_metric import get_top_n_labels_var, get_all_labels_var, get_all_labels_std, get_mean_iou, get_mean_volume


n_experiments = 1
n_epochs = 250
batches_per_epoch = 40

criterion = weighted_cross_entropy_with_logits

lr_opt = 0.015

p_dropout = 0.1
architecture = UNet3D_MC_Dropout(n_chans_in=n_chans_in, n_chans_out=n_chans_out, 
                                 n_filters_init=n_filters, p_dropout=p_dropout)

validate_step = None
# ood_ids = [] # TODO remove
N = 10

# final_metrics = final_metrics_ood
top_n_voxels = 500000
agg_functions = {'get_top_n_labels_var_500000': partial(get_top_n_labels_var, n=top_n_voxels),
                 'get_top_n_labels_var_1000000': partial(get_top_n_labels_var, n=2*top_n_voxels),
                 'get_top_n_labels_var_2000000': partial(get_top_n_labels_var, n=4*top_n_voxels),
                 'get_all_labels_var': get_all_labels_var,
                 'get_all_labels_std': get_all_labels_std,
                 'get_mean_iou': get_mean_iou,
                 'get_mean_volume': get_mean_volume}

evaluate_individual_metrics = partial(
    evaluate_individual_metrics_probably_with_ids_no_pred_mc_dropout,
    load_y=load_y,
    load_x=load_x,
    predict=predict,
    predict_logit=predict_logit,
    predict_with_dropout=partial(predictions_mc_dropout, N=N),
    test_ids=test_ids,
    agg_functions=agg_functions,
    segm_functions=final_metrics,
)

run_experiment = run(
    fix_seed(seed=seed),
    lock_dir(),
    architecture.to(device),
    if_missing(lambda p: [train_model, save_model_state(architecture, p)], saved_model_path),
    load_model_state(architecture, saved_model_path),
    if_missing(predict_to_dir, output_path=test_predictions_path),
    if_missing(evaluate_individual_metrics, results_path='test_metrics'),
)