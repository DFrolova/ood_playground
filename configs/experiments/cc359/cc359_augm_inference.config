from ...assets.core import *
from ...assets.utils.no_pred import *
# from ...assets.utils.no_pred_logits import *
from ...assets.dataset.cc359 import *
from ...assets.batch_iter.patch_sampling_3d import *
from ...assets.architecture.unet3d import *
from ...assets.cross_val.cv_cc359 import *
from ...assets.metric.metrics_3d import *

from dpipe.torch.functional import weighted_cross_entropy_with_logits
from ood.batch_iter.augmentations import rotate90, flip
from ood.metric.ood_metric import get_abs_ue_score, get_entropy


n_experiments = 1
n_epochs = 20
batches_per_epoch = 40

criterion = weighted_cross_entropy_with_logits

lr_opt = 0.005
seed = 0

validate_step = None

ood_ids = []
use_rot = False
k = 3
use_flip = True
ax = 1

@add_extract_dims(2)  # 3D -> (5D -> predict -> 5D) -> 3D
@patches_grid(pred_patch_size, pred_patch_stride, axis=SPATIAL_DIMS)  # image -> iter{patches} -> average
@divisible_shape(divisor=[16, ] * 3, padding_values=np.min, axis=SPATIAL_DIMS)
def predict(image):
    if use_rot and use_flip:
        return rotate90(flip(inference_step(flip(rotate90(image, k=k), ax=ax), architecture=architecture,
                                            activation=torch.sigmoid, amp=amp), ax=ax), k=4-k)
    elif use_rot and not use_flip:
        return rotate90(inference_step(rotate90(image, k=k), architecture=architecture, 
                                       activation=torch.sigmoid, amp=amp), k=4-k)
    elif use_flip:
        return flip(inference_step(flip(image, ax=ax), architecture=architecture, 
                                   activation=torch.sigmoid, amp=amp), ax=ax)
    return inference_step(image, architecture=architecture, activation=torch.sigmoid, amp=amp)


final_metrics = {'dice_score': dice_metric, 'sdice_score': sdice_metric, 'entropy': get_entropy, 
                 'abs_ue_score': get_abs_ue_score}